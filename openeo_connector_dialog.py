# -*- coding: utf-8 -*-
"""
/***************************************************************************
 OpenEODialog
                                 A QGIS plugin
 Plugin to access openEO compliant backends.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2019-07-18
        git sha              : $Format:%H$
        copyright            : (C) 2019 by Bernhard Goesswein
        email                : bernhard.goesswein@geo.tuwien.ac.at
 ***************************************************************************/
/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
########################################################################################################################
########################################################################################################################

import os
import json
import requests
from os.path import expanduser
from collections import OrderedDict
import webbrowser

from qgis.PyQt import uic, QtGui, QtWidgets
from qgis.PyQt.QtWidgets import QTreeWidgetItem, QTableWidgetItem, QMainWindow, QFileDialog
import qgis.PyQt.QtCore as QtCore
from qgis.core import QgsVectorLayer, QgsRasterLayer, QgsProject
from qgis.utils import iface

from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtWidgets import QPushButton, QHBoxLayout, QTextEdit, QListWidget, QListWidgetItem, QApplication, \
    QWidget, QLabel, QGridLayout, QVBoxLayout, QCalendarWidget, QDialog, QComboBox, QLineEdit

from PyQt5.QtCore import QDate, Qt, QSize, QSettings
from PyQt5.QtGui import QColor, QIcon, QPixmap

from .models.job import Job
from .models.result import Result
from .models.connect import Connection
from .models.processgraph import Processgraph
from .utils.logging import info, warning
from distutils.version import LooseVersion

from .temp_dialog import TempDialog
from .spatial_dialog import SpatialDialog
from .band_dialog import BandDialog

#os.environ["QT_AUTO_SCREEN_SCALE_FACTOR"] = "1"
QtWidgets.QApplication.setAttribute(QtCore.Qt.AA_EnableHighDpiScaling, True)  # enable highdpi scaling
QtWidgets.QApplication.setAttribute(QtCore.Qt.AA_UseHighDpiPixmaps, True)  # use highdpi icons

########################################################################################################################
########################################################################################################################

# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
FORM_CLASS, _ = uic.loadUiType(os.path.join(os.path.dirname(__file__), 'openeo_connector_dialog_base.ui'))


class OpenEODialog(QtWidgets.QDialog, FORM_CLASS):
    def __init__(self, parent=None, iface=None):
        """Constructor method
        """
        super(OpenEODialog, self).__init__(parent)
        # Set up the user interface from Designer through FORM_CLASS.
        # After self.setupUi() you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://qt-project.org/doc/qt-4.8/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect

        QApplication.setStyle("cleanlooks")

        self.iface = iface
        self.connection = Connection()
        self.processgraph = Processgraph()
        self.called = False
        self.called2 = False
        self.processes = None

        self.setupUi(self)
        ### Backend Issue:
        try:
            self.backendURL = requests.get('http://hub.openeo.org/api/backends', timeout=5)
        except:
            self.backendsALL = {}

        if self.backendURL.status_code == 200:
            self.backendsALL = self.backendURL.json()

        # self.processgraphEdit.setText(json.dumps(self.backendsALL, indent=4))

        backends = []

        for backend in self.backendsALL.values():
            if ".well-known" in str(backend):
                try:
                    backend_versions = requests.get(backend, timeout=5)

                    if backend_versions.status_code == 200:
                        backend_versions = backend_versions.json()
                        for versions in backend_versions.values():

                            for version in versions:
                                if "api_version" in version:
                                    if LooseVersion("0.4.0") <= LooseVersion(version["api_version"]):
                                        if "url" in version:
                                            backends.append(str(version["url"]))
                except:
                    print("Exception connecting to backend {}".format(backend))
            elif isinstance(backend, dict):
                for item in backend.values():
                    backends.append(str(item))
            else:
                backends.append(str(backend))

        # Change Names from Links to Title:
        backend_names = []
        for index in self.backendsALL.items():
            backend_names.append(index[0])
        # backend_names.sort(key=str.lower)

        self.backendEdit.addItems(backends)  # or Backends
        self.connectButton.clicked.connect(self.connect)
        self.disconnectButton.hide()
        self.disconnectButton.clicked.connect(self.disconnect)
        self.operationManualBtn.clicked.connect(self.user_manual)

        self.label_15.setStyleSheet("color: white")
        self.label_14.setStyleSheet("background-color: grey")

        self.collectionBox.currentTextChanged.connect(self.col_info)

        self.collectionBox.setEnabled(True)
        self.collectionBox.show()
        self.label_12.hide()

        self.processBox.currentTextChanged.connect(self.process_selected)

        self.clearButton.clicked.connect(self.clear)  # Clear Button
        self.sendButton.clicked.connect(self.send_job)  # Create Job Button
        self.sendButton_service.clicked.connect(self.send_service)
        self.sendButton.setEnabled(False)
        self.sendButton_service.setEnabled(False)
        self.tabWidget.currentChanged.connect(self.empty_window)

        self.refreshButton.clicked.connect(self.refresh_jobs)
        self.deleteButton.clicked.connect(self.del_job)
        self.deleteFinalButton.clicked.connect(self.delete_job_final)
        self.refreshButton_service.clicked.connect(self.refresh_services)
        self.deleteButton_service.clicked.connect(self.del_service)

        self.refreshButton.setEnabled(False)
        self.deleteButton.setEnabled(False)
        self.deleteFinalButton.setEnabled(False)
        self.refreshButton_service.setEnabled(False)
        self.deleteButton_service.setEnabled(False)
        self.deleteFinalButton_service.setEnabled(False)

        # Temporal Extent
        self.min_date = None
        self.max_date = None
        self.minimum_date = QDate()
        self.maximum_date = QDate()


        # Set initial button visibility correctly
        self.all_bands = []
        self.limit_west = -100000000000000000
        self.limit_east = 100000000000000000
        self.limit_north = 100000000000000000
        self.limit_south = -100000000000000000

        # Link to the Web Editor Demo Version:
        self.moveButton.clicked.connect(self.web_view)

        # Info Buttons about Datasets and Methods
        #self.collectionBox.setGeometry(10, 90, 401, 31)
        self.infoBtn2.setStyleSheet('''   
                                 border-image: url("./info_icon.png") 10 10 0 0;
                                 border-top: 10px transparent;
                                 border-bottom: 10px transparent;
                                 border-right: 0px transparent;
                                 border-left: 0px transparent''')
        self.infoBtn2.clicked.connect(self.pr_info)
        #self.processBox.setGeometry(10, 180, 401, 31)  # when add Button visible, set 381 to 291
        #self.infoBtn2.setGeometry(300, 180, 31, 31)  # remove, when add Button is visible
        self.infoBtn2.setVisible(False)
        self.infoBtn2.setEnabled(True)

        # Bands
        self.label_16.hide()
        self.label_16.setEnabled(False)

        # Adapt Job from Hub
        self.loadHubBtn.clicked.connect(self.load_job_from_hub)
        self.insertChangeBtn.clicked.connect(self.adapt_temporal)
        self.insertChangeBtn_2.clicked.connect(self.adapt_spatial)
        self.insertChangeBtn_3.clicked.connect(self.adapt_bands)
        self.insertChangeBtn_4.clicked.connect(self.adapt_collection)
        self.insertChangeBtn.setEnabled(False)
        self.insertChangeBtn_2.setEnabled(False)
        self.insertChangeBtn_3.setEnabled(False)
        self.insertChangeBtn_4.setEnabled(False)

        # self.set_font()
        # Jobs Tab
        self.init_jobs()
        self.init_services()

        self.tab_3.setEnabled(False)

    # def set_font(self):
    #    QtWidgets.QApplication.setAttribute(QtCore.Qt.AA_EnableHighDpiScaling, True)  # enable highdpi scaling
    #    QtWidgets.QApplication.setAttribute(QtCore.Qt.AA_UseHighDpiPixmaps, True)  # use highdpi icons

    def empty_window(self):
        window = str(self.processgraphEdit.toPlainText())
        if window == None:
            self.sendButton.setEnabled(False)
            self.sendButton_service.setEnabled(False)
        elif window == "":
            self.sendButton.setEnabled(False)
            self.sendButton_service.setEnabled(False)
        else:
            self.sendButton.setEnabled(True)
            self.sendButton_service.setEnabled(True)

    def set_canvas(self):
        iface.actionPan().trigger()
        if iface.activeLayer():
            crs = iface.activeLayer().crs().authid()
            extent = iface.mapCanvas().extent()
            self.east = round(extent.xMaximum(), 2)
            self.north = round(extent.yMaximum(), 2)
            self.west = round(extent.xMinimum(), 2)
            self.south = round(extent.yMinimum(), 2)
            spatial_extent = {}
            spatial_extent["west"] = self.west
            spatial_extent["east"] = self.east
            spatial_extent["north"] = self.north
            spatial_extent["south"] = self.south
            spatial_extent["crs"] = crs
            str_format = str(spatial_extent).replace("'", '"')
            # self.processgraphSpatialExtent.setText(str_format)
            self.check_spatial_cover()
        elif not iface.activeLayer():
            self.iface.messageBar().pushMessage("Please open a new layer to get extent from.", duration=5)

    def check_spatial_cover(self):
        west = self.west
        east = self.east
        north = self.north
        south = self.south
        if west < self.limit_west:
            self.iface.messageBar().pushMessage("Your Choice of extent is not covered by the data provider.",
                                                duration=5)
        if east > self.limit_east:
            self.iface.messageBar().pushMessage("Your Choice of extent is not covered by the data provider.",
                                                duration=5)
        if south < self.limit_south:
            self.iface.messageBar().pushMessage("Your Choice of extent is not covered by the data provider.",
                                                duration=5)
        if north > self.limit_north:
            self.iface.messageBar().pushMessage("Your Choice of extent is not covered by the data provider.",
                                                duration=5)

    def spatial_limits(self):
        collection_result = self.connection.list_collections()
        selected_process = str(self.collectionBox.currentText())
        for col in collection_result:
            if str(col['id']) == selected_process:
                if "extent" in col:
                    # in case nothing is listed:
                    self.limit_west = col['extent']['spatial'][0]
                    self.limit_south = col['extent']['spatial'][1]
                    self.limit_east = col['extent']['spatial'][2]
                    self.limit_north = col['extent']['spatial'][3]
                    # self.processgraphSpatialExtent.setText(str(self.limit_west) + " " + str(self.limit_east) + " " + str(self.limit_south) + " " + str(self.limit_north))

    def date_limits(self):
        # Get min and max date from each collection
        collection_result = self.connection.list_collections()
        selected_process = str(self.collectionBox.currentText())
        for col in collection_result:
            if str(col['id']) == selected_process:
                if "extent" in col:
                    # in case nothing is listed:
                    if col['extent']['temporal'] == "[]":
                        self.end_calendar.setMaximumDate(QDate.currentDate())
                        self.EndDateEdit.setMaximumDate(QDate.currentDate())
                    else:
                        # set minimum date
                        self.min_date = col['extent']['temporal'][0]
                        self.min_year = self.min_date[0:4]
                        self.min_month = self.min_date[5:7]
                        self.min_day = self.min_date[8:10]
                        self.minimum_date = QDate(int(self.min_year), int(self.min_month), int(self.min_day))
                        self.StartDateEdit.setDate(self.minimum_date)

                        # set maximum date
                        self.max_date = col['extent']['temporal'][1]
                        if self.max_date == None:
                            self.max_date = None
                            self.EndDateEdit.setDate(QDate.currentDate())
                        else:
                            self.max_year = self.max_date[0:4]
                            self.max_month = self.max_date[5:7]
                            self.max_day = self.max_date[8:10]
                            self.maximum_date = QDate(int(self.max_year), int(self.max_month), int(self.max_day))
                            self.EndDateEdit.setDate(self.maximum_date)

    def web_view(self):
        webbrowser.open("https://open-eo.github.io/openeo-web-editor/demo/")
        # QWebEngineView, QWebView...

    def web_view_close(self):
        self.webWindow.close()
        return

    def load_job_from_hub(self):
        try:
            example_jobs_URL = requests.get('http://hub.openeo.org/api/process_graphs', timeout=5)
        except:
            example_jobs_URL = []

        examples_job_list = example_jobs_URL.json()

        # Get names and process graphs of all available processes (7)
        self.example_jobs = []

        for item in examples_job_list:
            job = Job(title=item['title'], process_graph=item['process_graph'])
            self.example_jobs.append(job)

        # Open a window, where desired job can be selected
        self.example_jobs_window = QDialog(parent=self)
        hbox6 = QHBoxLayout()
        self.exampleJobBox = QListWidget()
        for job in self.example_jobs:
            job_item = QListWidgetItem(self.exampleJobBox)
            job_item.setFlags(
                job_item.flags() | QtCore.Qt.ItemIsSelectable)  # only one item can be selected this time
            job_item.setSelected(False)
            job_item.setText(job.title)  # add Titles as QListWidgetItems

        self.exampleJobBox.setMinimumWidth(500)

        closeWindowBtn = QPushButton('Show process graph \n and close window')
        hbox6.addWidget(self.exampleJobBox)
        hbox6.addWidget(closeWindowBtn)
        closeWindowBtn.clicked.connect(self.pick_job_from_hub)
        self.example_jobs_window.setLayout(hbox6)
        self.example_jobs_window.setWindowTitle('Select a Job')
        self.example_jobs_window.show()

    def pick_job_from_hub(self):
        self.insertChangeBtn.setEnabled(True)
        self.insertChangeBtn_2.setEnabled(True)
        self.insertChangeBtn_3.setEnabled(True)
        self.insertChangeBtn_4.setEnabled(True)


        selected_row = self.exampleJobBox.currentRow()
        self.example_jobs_window.close()
        self.example_job = json.loads(self.example_jobs[selected_row].process_graph)
        self.processgraphEdit.setText(json.dumps(self.example_job, indent=4))

    def adapt_temporal(self):

        #current_date = self.get_example_temporal()
        example_job = json.loads(self.processgraphEdit.toPlainText())

        self.temp_dialog = TempDialog(iface=self.iface, parent=self, minimum_date=self.minimum_date,
                                      maximum_date=self.maximum_date, max_date=self.max_date, pg_graph=example_job)

        self.temp_dialog.show()
        self.temp_dialog.raise_()
        self.temp_dialog.activateWindow()

    def adapt_spatial(self):

        example_job = json.loads(self.processgraphEdit.toPlainText())
        self.spatial_dialog = SpatialDialog(iface=self.iface, parent=self, pg_graph=example_job)

        self.spatial_dialog.show()
        self.spatial_dialog.raise_()
        self.spatial_dialog.activateWindow()

    def adapt_bands(self):

        example_job = json.loads(self.processgraphEdit.toPlainText())

        self.band_dialog = BandDialog(iface=self.iface, parent=self, pg_graph=example_job)

        self.band_dialog.show()
        self.band_dialog.raise_()
        self.band_dialog.activateWindow()

    def adapt_collection(self):

        col_window = QDialog(parent=self)

        process_combo = QComboBox()
        process_combo.currentTextChanged.connect(lambda: self.col_window_update_selection(col_combo, process_combo))

        col_combo = QComboBox()
        ok_button = QPushButton()
        cancel_button = QPushButton()

        ok_button.setText("Ok")
        cancel_button.setText("Cancel")

        all_items = [self.collectionBox.itemText(i) for i in range(self.collectionBox.count())]
        col_combo.addItems(all_items)

        selected_id = self.get_example_collection()
        col_combo.setCurrentText(selected_id)

        col_combo.setMinimumWidth(250)
        process_combo.setMinimumWidth(250)

        example_job = json.loads(self.processgraphEdit.toPlainText())
        for key, _ in example_job.items():
            if example_job[key]["process_id"] == "load_collection":
                process_combo.addItem("{} - {}".format(example_job[key]["process_id"], key))

        ok_button.clicked.connect(lambda: self.change_example_collection(col_combo.currentText(),
                                                                         col_window,
                                                                         process_id=process_combo.currentText()))
        cancel_button.clicked.connect(col_window.reject)

        vbox = QVBoxLayout()
        vbox.addWidget(process_combo)
        vbox.addWidget(col_combo)

        hbox = QHBoxLayout()
        hbox.addWidget(ok_button)
        hbox.addWidget(cancel_button)

        vbox.addLayout(hbox)
        col_window.setLayout(vbox)
        col_window.setWindowTitle('Choose Collection')
        col_window.show()
        self.col_window_update_selection(col_combo, process_combo)

    def col_window_update_selection(self, col_combo, process_combo):
        example_job = json.loads(self.processgraphEdit.toPlainText())
        process_id = process_combo.currentText().split(" - ")

        if len(process_id) >= 2:
            process_id = process_id[1]
        else:
            process_id = ""

        if process_id:
            if example_job[process_id]["process_id"] == "load_collection":
                if col_combo.findText(example_job[process_id]["arguments"]["id"]):
                    col_combo.addItem(example_job[process_id]["arguments"]["id"])

    def get_example_collection(self):
        example_job = json.loads(self.processgraphEdit.toPlainText())
        selected_id = ""
        for key, _ in example_job.items():
            if example_job[key]["process_id"] == "load_collection":
                selected_id = example_job[key]["arguments"]["id"]
        return selected_id

    def change_example_collection(self, col_id, dialog, process_id=None):
        example_job = json.loads(self.processgraphEdit.toPlainText())

        if process_id:
            if example_job[process_id]["process_id"] == "load_collection":
                example_job[process_id]["arguments"]["id"] = col_id
        else:
            for key, _ in example_job.items():
                if example_job[key]["process_id"] == "load_collection":
                    example_job[key]["arguments"]["id"] = col_id

        self.processgraphEdit.setText(json.dumps(example_job, indent=4))
        dialog.close()

    def change_example_temporal(self, start_date=None, end_date=None, process_id=None):
        self.tabWidget.setCurrentIndex(1)

        new_start_date = start_date
        new_end_date = end_date

        dates = [new_start_date, new_end_date]

        example_job = json.loads(self.processgraphEdit.toPlainText())
        if process_id:
            if example_job[process_id]["process_id"] == "load_collection":
                example_job[process_id]["arguments"]["temporal_extent"] = dates
            elif example_job[process_id]["process_id"] == "filter_temporal":
                example_job[process_id]["arguments"]["extent"] = dates
        else:
            for key, _ in example_job.items():
                if example_job[key]["process_id"] == "load_collection":
                    example_job[key]["arguments"]["temporal_extent"] = dates

        self.processgraphEdit.setText(json.dumps(example_job, indent=4))

    def get_example_temporal(self):
        example_job = json.loads(self.processgraphEdit.toPlainText())
        temporal = ""
        for key, _ in example_job.items():
            if example_job[key]["process_id"] == "load_collection":
                if "temporal" in example_job[key]["arguments"]:
                    temporal = example_job[key]["arguments"]["temporal"]
        return json.loads(temporal)

    def change_example_spatial(self, spatial_extent, process_id=None):
        self.tabWidget.setCurrentIndex(1)

        example_job = json.loads(self.processgraphEdit.toPlainText())
        if process_id:
            if example_job[process_id]['process_id'] == "load_collection":
                #if "spatial_extent" in example_job[process_id]['arguments']:
                example_job[process_id]['arguments']['spatial_extent'] = json.loads(spatial_extent)
            elif example_job[process_id]['process_id'] == "filter_spatial":
                example_job[process_id]['arguments']['extent'] = json.loads(spatial_extent)
        else:
            for key, _ in example_job.items():
                if example_job[key]['process_id'] == "load_collection":
                    if "spatial_extent" in example_job[key]['arguments']:
                        example_job[key]['arguments']['spatial_extent'] = json.loads(spatial_extent)

        self.processgraphEdit.setText(json.dumps(example_job, indent=4))

    def get_example_spatial(self):
        example_job = json.loads(self.processgraphEdit.toPlainText())
        extent = ""
        for key, _ in example_job.items():
            if example_job[key]["process_id"] == "load_collection":
                if "spatial_extent" in example_job[key]["arguments"]:
                    extent = example_job[key]["arguments"]["spatial_extent"]
        return extent

    def change_example_bands(self, band_choices, process_id=None):
        self.tabWidget.setCurrentIndex(1)

        example_job = json.loads(self.processgraphEdit.toPlainText())

        if process_id:
            if example_job[process_id]['process_id'] in ["load_collection", "filter_bands"]:
                example_job[process_id]['arguments']['bands'] = json.loads(band_choices)
        else:
            for key, _ in example_job.items():
                if example_job[key]['process_id'] == "load_collection":
                    example_job[key]['arguments']['bands'] = json.loads(band_choices)

        self.processgraphEdit.setText(json.dumps(example_job, indent=4))

    def get_example_bands(self):
        example_job = json.loads(self.processgraphEdit.toPlainText())
        bands = ""
        for key, _ in example_job.items():
            if example_job[key]["process_id"] == "load_collection":
                bands = example_job[key]["arguments"]["bands"]
        return bands

    def get_pg_collection(self, process_id=None):
        example_job = json.loads(self.processgraphEdit.toPlainText())
        if process_id:
            if example_job[process_id]['process_id'] == "load_collection":
                return example_job[process_id]['arguments']['id']

        for key, _ in example_job.items():
            if example_job[key]['process_id'] == "load_collection":
                return example_job[key]['arguments']['id']

    def user_manual(self):
        self.umWindow = QDialog(parent=self)
        self.grid = QGridLayout()

        # User Manual Text
        self.text = QLabel()
        user_manual_text = open(os.path.join(os.path.dirname(__file__), './user_manual_text.txt')).read()
        self.text.setText(str(user_manual_text))
        # Title
        self.title = QLabel()
        self.title.setText("User Manual \n ")
        self.startText = QLabel()
        self.startText.setText("1. At first, please focus on the upper part (header) of the openEO Plugin. "
                               "There, you can choose a back-end and enter your login credentials. \nBy clicking"
                               "the “Connect”-Button, you will be connected with the chosen back-end. \nIf the connection "
                               "was successful you will see it in the Status text. \n")
        # openEO Header Image
        self.image = QLabel()
        self.image.setPixmap(QPixmap(os.path.join(os.path.dirname(__file__), 'openEO_plugin_header.png')))

        self.grid.setSpacing(4)
        self.grid.addWidget(self.title, 0, 0)
        self.grid.addWidget(self.startText, 1, 0)
        self.grid.addWidget(self.image, 2, 0)
        self.grid.addWidget(self.text, 4, 0)
        self.umWindow.setLayout(self.grid)
        self.umWindow.setWindowTitle('User Manual')
        self.umWindow.show()

        self.jobsTableWidget.setColumnCount(7)
        self.jobsTableWidget.setHorizontalHeaderLabels(['Job Id', 'Description/Error', 'Submission Date', 'Status',
                                                        'Execute', 'Display', 'Information'])
        header = self.jobsTableWidget.horizontalHeader()
        header.setSectionResizeMode(0, QtWidgets.QHeaderView.ResizeToContents)
        header.setSectionResizeMode(1, QtWidgets.QHeaderView.Stretch)
        header.setSectionResizeMode(2, QtWidgets.QHeaderView.ResizeToContents)

    def connect(self):
        """
        Connect to the backend via the given credentials. It will connect via BasicAuthentication and Bearertoken.
        If there are no credentials, it connects to the backend without authentication.
        This method also loads all collections and processes from the backend.
        """
        url = self.backendEdit.currentText()
        pwd = self.passwordEdit.text()
        user = self.usernameEdit.text()
        if user == "":
            user = None
        if pwd == "":
            pwd = None

        auth = self.connection.connect(url, username=user, password=pwd)

        if not auth:
            warning(self.iface, "Authentication failed!")
            return

        collection_result = self.connection.list_collections()
        process_result = self.connection.list_processes()
        self.processes = process_result

        #self.collectionBox.setGeometry(10, 90, 361, 31)
        self.infoBtn2.setVisible(True)

        #self.processBox.setGeometry(10, 180, 281, 31)  # when add Button is visible - set 351 to 261

        self.collectionBox.clear()
        self.processBox.clear()

        # Load Collections from Backend
        self.collectionBox.addItem("Choose one of the data sets listed below")
        for col in collection_result:
            if "id" in col:
                self.collectionBox.addItem(col['id'])

        # Load Processes from Backend
        self.processBox.addItem("Select a job")
        for pr in process_result:
            if "id" in pr:
                self.processBox.addItem(pr['id'])

        self.refresh_jobs()
        self.refresh_services()

        if len(collection_result) == 0 and len(process_result) == 0:
            warning(self.iface, "Backend URL does not have collections or processes defined, or is not valid!")
            return

        # Update Status text
        boldFont = QtGui.QFont()
        boldFont.setBold(True)
        self.statusLabel.setFont(boldFont)
        if user:
            self.statusLabel.setText("Connected to {} as {}".format(url, user))
            #self.bands_selected()
        else:
            self.statusLabel.setText("Connected to {} without user".format(url))

        self.connectButton.hide()
        self.disconnectButton.show()

        self.collectionBox.setEnabled(True)

        self.tab_3.setEnabled(True)

        self.backend_info()

    def disconnect(self):
        self.statusLabel.setText("Disconnected")
        self.usernameEdit.clear()
        self.passwordEdit.clear()
        self.connectButton.show()
        self.disconnectButton.hide()
        self.collectionBox.clear()
        #self.collectionBox.setEnabled(False)
        #self.label_6.setEnabled(False)

        if self.backendEdit.currentText() == "None of the listed ones match":
            url = self.backendEdit2.text()
        else:
            url = self.backendEdit.currentText()
        pwd = self.passwordEdit.text()
        user = self.usernameEdit.text()
        if user == "":
            user = None
        if pwd == "":
            pwd = None

        self.connection.connect(url, user, pwd) # disconnect
        self.refreshButton.setEnabled(False)
        self.deleteButton.setEnabled(False)
        self.deleteFinalButton.setEnabled(False)
        self.deleteFinalButton.setEnabled(False)
        self.refreshButton_service.setEnabled(False)
        self.deleteButton_service.setEnabled(False)
        self.deleteFinalButton_service.setEnabled(False)
        self.jobsTableWidget.clear()
        self.servicesTableWidget.clear()

        self.tab_3.setEnabled(False)

    def col_info(self):
        collection_info_result = self.connection.list_collections()
        selected_col = str(self.collectionBox.currentText())
        for col_info in collection_info_result:
            if str(col_info['id']) == selected_col:
                if "description" in col_info:
                    self.collectionInfo.setText(str(col_info['id']) + ': ' + str(col_info['description']))

    def backend_info(self):
        backend_info = self.connection.backend_info()

        if "description" in backend_info:
            self.backendInfo.setText(str(backend_info["description"]))

    def pr_info(self):
        process_info_result = self.connection.list_processes()
        selected_process = str(self.processBox.currentText())
        for pr_info in process_info_result:
            if str(pr_info['id']) == selected_process:
                if "description" in pr_info:
                    self.infoWindow2 = QDialog(parent=self)
                    self.hbox2 = QHBoxLayout()
                    self.infoBox = QTextEdit()
                    if "returns" in pr_info:
                        self.infoBox.setText(
                            str(str(pr_info['id']) + ': ' + str(pr_info['description']) + "\n\n Returns: \n" + str(
                                pr_info['returns']['description'])))
                    else:
                        self.infoBox.setText(
                            str(str(pr_info['id']) + ': ' + str(pr_info['description'])))
                    self.infoBox.setReadOnly(True)
                    self.infoBox.setMinimumWidth(500)
                    self.infoBox.setMinimumHeight(500)
                    self.hbox2.addWidget(self.infoBox)
                    self.infoWindow2.setLayout(self.hbox2)
                    #self.infoWindow2.setGeometry(400, 400, 600, 350)
                    self.infoWindow2.setWindowTitle('Process Information')
                    self.infoWindow2.show()
                    # self.processgraphEdit.setText(str(pr_info['id']) + ": " + str(pr_info['description']))

    def job_info(self, row):
        """
        Returns detailed information about a submitted batch job in a PopUp-Window, such as:
        - Start time
        - Description
        - Progress
        - Cost
        - ...
        :param row: Integer number of the row the button is clicked.
        """

        job_id = self.jobsTableWidget.item(row, 1).text()
        job_info = self.connection.job_info(job_id)
        self.infoWindow3 = QDialog(parent=self)
        self.hbox3 = QHBoxLayout()
        self.infoBox3 = QTextEdit()
        self.infoBox3.setText(str(job_info))
        self.infoBox3.setReadOnly(True)
        self.hbox3.addWidget(self.infoBox3)
        self.infoWindow3.setLayout(self.hbox3)
        #self.infoWindow3.setGeometry(400, 400, 600, 450)
        self.infoWindow3.setWindowTitle('Job Information')
        self.infoWindow3.show()

    def service_info(self, row):
        service_id = self.servicesTableWidget.item(row, 1).text()
        service_info = self.connection.service_info(service_id)
        self.infoWindow5 = QDialog(parent=self)
        self.hbox7 = QHBoxLayout()
        self.infoBox2 = QTextEdit()
        self.infoBox2.setText(str(service_info))
        self.infoBox2.setReadOnly(True)
        self.hbox7.addWidget(self.infoBox2)
        self.infoWindow5.setLayout(self.hbox7)
        #self.infoWindow5.setGeometry(400, 400, 600, 450)
        self.infoWindow5.setWindowTitle('Service Information')
        self.infoWindow5.show()

    def pg_info_job(self, row):
        """
        Returns detailed information about a the process graph of a batch job in a PopUp-Window:
        :param row: Integer number of the row the button is clicked.
        """
        job_id = self.jobsTableWidget.item(row, 1).text()
        process_graph_job = self.connection.pg_info_job(job_id)

        self.infoWindow4 = QDialog(parent=self)
        self.hbox5 = QVBoxLayout()
        self.infoBox4 = QTextEdit()
        self.infoBox4.setText(json.dumps(process_graph_job, indent=4))
        self.infoBox4.setReadOnly(True)
        self.infoBox4.setMinimumWidth(500)
        self.infoBox4.setMinimumHeight(800)
        self.copy_and_adaptBtn = QPushButton('Copy and Adapt Job Process Graph in QGIS Plugin')
        self.copy_and_adaptBtn.move(20, 10)
        self.hbox5.addWidget(self.infoBox4)
        self.hbox5.addWidget(self.copy_and_adaptBtn)
        self.infoWindow4.setLayout(self.hbox5)
        #self.infoWindow4.setGeometry(400, 400, 600, 450)
        self.infoWindow4.setWindowTitle('Job Process Graph')
        self.infoWindow4.show()
        self.copy_and_adaptBtn.clicked.connect(self.copy_and_adapt_job)

    def pg_info_service(self, row):
        """
        Returns detailed information about a the process graph of a batch job in a PopUp-Window:
        :param row: Integer number of the row the button is clicked.
        """
        service_id = self.servicesTableWidget.item(row, 1).text()
        process_graph_service = self.connection.pg_info_service(service_id)

        self.infoWindow6 = QDialog(parent=self)
        self.hbox8 = QVBoxLayout()
        self.infoBox5 = QTextEdit()
        self.infoBox5.setText(json.dumps(process_graph_service, indent=4))
        self.infoBox5.setReadOnly(True)
        self.infoBox5.setMinimumWidth(500)
        self.infoBox5.setMinimumHeight(800)
        self.copy_adaptBtn = QPushButton('Copy and Adapt Service Process Graph in QGIS Plugin')
        self.copy_adaptBtn.move(120, 280)
        self.hbox8.addWidget(self.infoBox5)
        self.hbox8.addWidget(self.copy_adaptBtn, Qt.RightButton)
        self.infoWindow6.setLayout(self.hbox8)
        #self.infoWindow6.setGeometry(400, 400, 600, 450)
        self.infoWindow6.setWindowTitle('Service Process Graph')
        self.infoWindow6.show()
        self.copy_adaptBtn.clicked.connect(self.copy_and_adapt_service)

    def copy_and_adapt_job(self):
        self.processgraphEdit.setText(self.infoBox4.toPlainText()) #str().replace("'", '"').replace("None", '"None"').replace("True", '"True"'))
        self.infoWindow4.close()
        self.tabWidget.setCurrentIndex(1)

        # Enable Buttons
        self.insertChangeBtn.setEnabled(True)
        self.insertChangeBtn_2.setEnabled(True)
        self.insertChangeBtn_3.setEnabled(True)
        self.insertChangeBtn_4.setEnabled(True)

    def copy_and_adapt_service(self):
        self.processgraphEdit.setText(json.dumps(str(self.infoBox4.toPlainText()), indent=4)) #(str(self.infoBox5.toPlainText()).replace("'", '"').replace("None", '"None"').replace("True", '"True"'))
        self.infoWindow6.close()
        self.tabWidget.setCurrentIndex(1)

        # Enable Buttons
        self.insertChangeBtn.setEnabled(True)
        self.insertChangeBtn_2.setEnabled(True)
        self.insertChangeBtn_3.setEnabled(True)
        self.insertChangeBtn_4.setEnabled(True)

    def init_jobs(self):
        """
        Initializes the jobs table
        """
        self.jobsTableWidget.clear()

        self.jobsTableWidget.setColumnCount(8)
        self.jobsTableWidget.setHorizontalHeaderLabels(['Job Title', 'Job ID', 'Status', 'Execute', 'Display',
                                                        'Information', 'Process Graph', 'Error'])
        header = self.jobsTableWidget.horizontalHeader()
        self.jobsTableWidget.setSortingEnabled(True)
        header.setSectionResizeMode(0, QtWidgets.QHeaderView.Interactive)
        header.setSectionResizeMode(1, QtWidgets.QHeaderView.Interactive)
        header.setSectionResizeMode(2, QtWidgets.QHeaderView.Interactive)
        header.setSectionResizeMode(3, QtWidgets.QHeaderView.Interactive)
        header.setSectionResizeMode(4, QtWidgets.QHeaderView.Interactive)
        header.setSectionResizeMode(5, QtWidgets.QHeaderView.Interactive)
        header.setSectionResizeMode(6, QtWidgets.QHeaderView.Interactive)
        header.setSectionResizeMode(7, QtWidgets.QHeaderView.Interactive)

    def init_services(self):
        """
        Initializes the services table
        """
        self.servicesTableWidget.clear()

        self.servicesTableWidget.setColumnCount(6)
        self.servicesTableWidget.setHorizontalHeaderLabels(['Service Title', 'Service ID', 'Display', 'Information',
                                                            'Process Graph', 'Error'])

        header = self.servicesTableWidget.horizontalHeader()
        self.servicesTableWidget.setSortingEnabled(True)
        header.setSectionResizeMode(0, QtWidgets.QHeaderView.Interactive)
        header.setSectionResizeMode(1, QtWidgets.QHeaderView.Interactive)
        header.setSectionResizeMode(2, QtWidgets.QHeaderView.Interactive)
        header.setSectionResizeMode(3, QtWidgets.QHeaderView.Interactive)
        header.setSectionResizeMode(4, QtWidgets.QHeaderView.Interactive)
        header.setSectionResizeMode(5, QtWidgets.QHeaderView.Interactive)

    def refresh_jobs(self):
        """
        Refreshes the job table, so fetches all jobs of the user from the backend and lists them in the table.
        This method also generates the "Execute" and "Display" buttons.
        """

        jobs = self.connection.user_jobs()

        if not isinstance(jobs, list):
            jobs = []

        self.init_jobs()
        self.jobsTableWidget.setRowCount(len(jobs))
        row = 0

        for val in jobs:
            if "id" in val:
                qitem = QTableWidgetItem(val["id"])
                qitem.setFlags(QtCore.Qt.ItemIsEnabled)
                self.jobsTableWidget.setItem(row, 1, qitem)

            if "title" in val:
                if val['title'] == None:
                    qitem = QTableWidgetItem("Untitled Job!")
                    qitem.setFlags(QtCore.Qt.ItemIsEnabled)
                    self.jobsTableWidget.setItem(row, 0, qitem)
                else:
                    qitem = QTableWidgetItem(val["title"])
                    qitem.setFlags(QtCore.Qt.ItemIsEnabled)
                    self.jobsTableWidget.setItem(row, 0, qitem)

            if "error" in val:
                if val["error"]:
                    if "message" in val["error"]:
                        qitem = QPushButton(self.jobsTableWidget)
                        qitem.setText("Show")
                        #qitem.setFlags(QtCore.Qt.ItemIsEnabled)
                        msg = val["error"]["message"]
                        qitem.clicked.connect(lambda: self.show_error_message(msg))
                        self.jobsTableWidget.setCellWidget(row, 7, qitem)

            execBtn = QPushButton(self.jobsTableWidget)
            execBtn.setIcon(QIcon(os.path.join(os.path.dirname(__file__), 'execute_icon.png')))
            execBtn.setIconSize(QSize(21, 21))

            if "status" in val:
                qitem = QTableWidgetItem(val["status"])
                qitem.setFlags(QtCore.Qt.ItemIsEnabled)
                self.jobsTableWidget.setItem(row, 2, qitem)

                if val["status"] == "finished":
                    self.jobsTableWidget.item(row, 2).setBackground(QColor(75, 254, 40, 160))
                    dispBtn = QPushButton(self.jobsTableWidget)
                    dispBtn.setIcon(QIcon(os.path.join(os.path.dirname(__file__), 'display_icon.png')))
                    dispBtn.setIconSize(QSize(29, 29))
                    self.jobsTableWidget.setCellWidget(row, 4, dispBtn)
                    dispBtn.clicked.connect(lambda *args, row=row: self.job_display(row))
                    iface.actionZoomIn().trigger()

                elif val["status"] == "submitted":
                    self.jobsTableWidget.item(row, 2).setBackground(QColor(254, 178, 76, 200))

                elif val["status"] == "error":
                    self.jobsTableWidget.item(row, 2).setBackground(QColor(254, 100, 100, 200))

            self.jobsTableWidget.setCellWidget(row, 3, execBtn)
            execBtn.clicked.connect(lambda *args, row=row: self.job_execute(row))

            self.infoBtn3 = QPushButton(self.jobsTableWidget)
            self.infoBtn3.setIcon(QIcon(os.path.join(os.path.dirname(__file__), 'info_icon.png')))
            self.infoBtn3.setIconSize(QSize(25, 25))
            self.processGraphBtn = QPushButton(self.jobsTableWidget)
            self.processGraphBtn.setIcon(QIcon(os.path.join(os.path.dirname(__file__), 'processGraph_icon.png')))
            self.processGraphBtn.setIconSize(QSize(22, 22))
            self.jobsTableWidget.setCellWidget(row, 5, self.infoBtn3)
            self.infoBtn3.clicked.connect(lambda *args, row=row: self.job_info(row))
            self.jobsTableWidget.setCellWidget(row, 6, self.processGraphBtn)
            self.processGraphBtn.clicked.connect(lambda *args, row=row: self.pg_info_job(row))

            self.refreshButton.setEnabled(True)
            self.deleteButton.setEnabled(True)
            self.deleteFinalButton.setEnabled(True)
            self.refreshButton_service.setEnabled(True)
            self.deleteButton_service.setEnabled(True)
            self.deleteFinalButton_service.setEnabled(True)
            self.deleteFinalButton.clicked.connect(lambda *args, row=row: self.delete_service_final(row))
            self.deleteFinalButton_service.clicked.connect(lambda *args, row=row: self.delete_service_final(row))

            row += 1

    def show_error_message(self, msg):
        """
                Shows a detailed information about
                a the error of a batch job in a PopUp-Window:
                :param msg: Error message that should be shown in the window.
                """
        #service_id = self.servicesTableWidget.item(row, 1).text()
        #process_graph_service = self.connection.pg_info_service(service_id)

        self.infoWindow6 = QDialog(parent=self)
        self.hbox8 = QVBoxLayout()
        self.infoBox5 = QTextEdit()
        self.infoBox5.setText(msg)
        self.infoBox5.setReadOnly(True)
        self.infoBox5.setMinimumWidth(500)
        self.infoBox5.setMinimumHeight(800)
        self.hbox8.addWidget(self.infoBox5)
        self.infoWindow6.setLayout(self.hbox8)
        # self.infoWindow6.setGeometry(400, 400, 600, 450)
        self.infoWindow6.setWindowTitle('Error Message')
        self.infoWindow6.show()

    def refresh_services(self):
        """
        Refreshes the job table, so fetches all jobs of the user from the backend and lists them in the table.
        This method also generates the "Execute" and "Display" buttons.
        """

        services = self.connection.user_services()

        if not isinstance(services, list):
            services = []

        self.init_services()
        self.servicesTableWidget.setRowCount(len(services))
        row = 0

        for val in services:
            # self.processgraphEdit.setText(val)
            if "title" in val:
                if val['title'] == None:
                    qitem = QTableWidgetItem("Untitled Service!")
                    qitem.setFlags(QtCore.Qt.ItemIsEnabled)
                    self.servicesTableWidget.setItem(row, 0, qitem)
                else:
                    qitem = QTableWidgetItem(val["title"])
                    qitem.setFlags(QtCore.Qt.ItemIsEnabled)
                    self.servicesTableWidget.setItem(row, 0, qitem)

            if "id" in val:
                qitem = QTableWidgetItem(val['id'])
                qitem.setFlags(QtCore.Qt.ItemIsEnabled)
                self.servicesTableWidget.setItem(row, 1, qitem)

            if "error" in val:
                if val["error"]:
                    if "message" in val["error"]:
                        qitem = QPushButton(self.servicesTableWidget)
                        qitem.setText("Show")
                        # qitem.setFlags(QtCore.Qt.ItemIsEnabled)
                        msg = val["error"]["message"]
                        qitem.clicked.connect(lambda: self.show_error_message(msg))
                        self.servicesTableWidget.setCellWidget(row, 5, qitem)

            #elif "description" in val:
            #    qitem = QTableWidgetItem(val["description"])
            #    qitem.setFlags(QtCore.Qt.ItemIsEnabled)
            #    self.servicesTableWidget.setItem(row, 5, qitem)

            #if "submitted" in val:
            #    qitem = QTableWidgetItem(val["submitted"])
            #    qitem.setFlags(QtCore.Qt.ItemIsEnabled)
            #    self.servicesTableWidget.setItem(row, 6, qitem)

            displayBtn = QPushButton(self.servicesTableWidget)
            displayBtn.setIcon(QIcon(os.path.join(os.path.dirname(__file__), 'display_icon.png')))
            displayBtn.setIconSize(QSize(29, 29))

            #if "type" in val:
            #    qitem = QTableWidgetItem(val["type"])
            #    qitem.setFlags(QtCore.Qt.ItemIsEnabled)
            #    self.servicesTableWidget.setItem(row, 7, qitem)

            self.servicesTableWidget.setCellWidget(row, 2, displayBtn)
            displayBtn.clicked.connect(lambda *args, row=row: self.service_execute(val["url"], val["id"]))

            self.infoBtn4 = QPushButton(self.jobsTableWidget)
            self.infoBtn4.setIcon(QIcon(os.path.join(os.path.dirname(__file__), 'info_icon.png')))
            self.infoBtn4.setIconSize(QSize(25, 25))
            self.servicesTableWidget.setCellWidget(row, 3, self.infoBtn4)
            self.infoBtn4.clicked.connect(lambda *args, row=row: self.service_info(row))

            self.processGraphBtn_service = QPushButton(self.jobsTableWidget)
            self.processGraphBtn_service.setIcon(QIcon(os.path.join(os.path.dirname(__file__), 'processGraph_icon.png')))
            self.processGraphBtn_service.setIconSize(QSize(22, 22))
            self.servicesTableWidget.setCellWidget(row, 4, self.processGraphBtn_service)
            self.processGraphBtn_service.clicked.connect(lambda *args, row=row: self.pg_info_service(row))

            row += 1

    def service_execute(self, url, id):
        """
        Executes the job of the given row of the job table.
        This method is called after the "Execute" button is clicked at the job table.
        :param row: Integer number of the row the button is clicked.
        """
        urlWithParams = 'type=xyz&url={}'.format(url)
        # urlWithParams = 'type=xyz&url={}&zmax=19&zmin=0&crs=EPSG3857'.format(url)

        rlayer = QgsRasterLayer(urlWithParams, 'OpenEO-{}'.format(id), 'wms')

        # rlayer = QgsRasterLayer("type=xyz&url=http://c.tile.openstreetmap.org/{z}/{x}/{y}.png", "OSM", "wms")

        if rlayer.isValid():
            QgsProject.instance().addMapLayer(rlayer)
        else:
            print('invalid layer')

    def job_execute(self, row):
        """
        Executes the job of the given row of the job table.
        This method is called after the "Execute" button is clicked at the job table.
        :param row: Integer number of the row the button is clicked.
        """
        job_id = self.jobsTableWidget.item(row, 1).text()
        self.connection.job_start(job_id)
        self.refresh_jobs()

    def job_display(self, row):
        """
        Displays the job of the given row of the job table on a new QGis Layer.
        This method is called after the "Display" button is clicked at the job table.
        :param row: Integer number of the row the button is clicked.
        """
        job_id = self.jobsTableWidget.item(row, 1).text()
        process_graph_job = self.connection.pg_info_job(job_id)
        download_dir = self.connection.job_result_download(job_id)
        if download_dir:
            info(self.iface, "Downloaded to {}".format(download_dir))
            result = Result(path=download_dir, process_graph=process_graph_job)
            if iface.activeLayer():
                crs_background = iface.activeLayer().crs().authid()
                QSettings().setValue('/Projections/defaultBehaviour', 'useGlobal')
                QSettings().setValue('/Projections/layerDefaultCrs', crs_background)
            else:
                QSettings().setValue('/Projections/defaultBehaviour', 'useGlobal')
                QSettings().setValue('/Projections/layerDefaultCrs', 'EPSG:4326')

            result.display()
            iface.zoomToActiveLayer()

        self.refresh_jobs()

    def send_job(self):
        """
        Sends the current process graph to the backend to create a new job.
        """
        title_window = QDialog(parent=self)

        title = QLineEdit()
        ok_button = QPushButton()
        cancel_button = QPushButton()

        title.setMinimumWidth(200)

        ok_button.setText("Ok")
        cancel_button.setText("Cancel")

        ok_button.clicked.connect(lambda: self.send_job_backend(title.text(), title_window))
        cancel_button.clicked.connect(title_window.reject)

        vbox = QVBoxLayout()
        vbox.addWidget(title)

        hbox = QHBoxLayout()
        hbox.addWidget(ok_button)
        hbox.addWidget(cancel_button)

        vbox.addLayout(hbox)
        title_window.setLayout(vbox)
        title_window.setWindowTitle('Choose Title')
        title_window.show()

    def send_job_backend(self, title=None, dialog=None):
        graph = self.processgraphEdit.toPlainText()
        # info(self.iface, graph)
        response = self.connection.job_create(json.loads(graph), title=title)
        if response.status_code == 201:
            info(self.iface, "Successfully created new job, Response: {}".format(response.status_code))
        else:
            warning(self.iface, "Not able to created new job, Response: {}".format(str(response.json())))

        self.refresh_jobs()
        if dialog:
            dialog.close()

    def send_service(self):
        """
        Sends the current process graph to the backend to create a new service.
        """
        graph = self.processgraphEdit.toPlainText()
        # info(self.iface, graph)
        response = self.connection.service_create(json.loads(graph))
        if response.status_code == 201:
            info(self.iface, "Successfully created new service, Response: {}".format(response.status_code))
        else:
            warning(self.iface, "Not able to created new service, Response: {}".format(str(response.json())))

        self.refresh_services()

    def del_job(self):
        self.chosenRow = self.jobsTableWidget.currentRow()
        self.jobsTableWidget.removeRow(self.chosenRow)

    def delete_job_final(self, row):

        job_id = self.jobsTableWidget.item(row, 1).text()
        self.connection.delete_job(job_id)
        self.refresh_jobs()

    def del_service(self):
        self.chosenRow = self.servicesTableWidget.currentRow()
        self.servicesTableWidget.removeRow(self.chosenRow)

    def delete_service_final(self, row):
        service_id = self.servicesTableWidget.item(row, 1).text()
        selected_item = self.servicesTableWidget.currentRow()
        selected_service_id = self.servicesTableWidget.item(int(selected_item), 1).text()
        #self.processgraphEdit.setText(str(selected_item) + " " + str(service_id) + " " + self.servicesTableWidget.item(int(selected_item), 1).text())
        if service_id == selected_service_id:
            self.connection.delete_service(selected_item)
            self.refresh_services()
        else:
            self.processgraphEdit.setText("It does not work that way")

    def clear(self):
        self.processgraphEdit.clear()
        self.sendButton.setEnabled(False)
        self.sendButton_service.setEnabled(False)

    def reload_processgraph_view(self):
        """
        Reloads the process graph tree widget by loading the current processgraph into it.
        """
        # widget = self.processgraphWidget
        # self.load_dict_into_widget(widget, self.processgraph.graph)
        self.processgraphEdit.setText(json.dumps(self.processgraph.graph, indent=2, sort_keys=True))
        # widget.show()

    def process_selected(self):
        """
        Gets called if a new process is selected at the process combobox.
        It loads all agruments with their type and an example (if exist) into the value
        """
        self.processTableWidget.clear()
        for p in self.processes:
            if "id" in p:
                if p['id'] == str(self.processBox.currentText()):
                    process = p
                    if "parameters" in process:
                        # info(self.iface, "New Process {}".format(process['parameters']))
                        self.processTableWidget.setRowCount(len(process['parameters']))
                        self.processTableWidget.setColumnCount(3)
                        self.processTableWidget.setHorizontalHeaderLabels(['Parameter', 'Type', 'Example'])
                        header = self.processTableWidget.horizontalHeader()
                        header.setSectionResizeMode(0, QtWidgets.QHeaderView.ResizeToContents)
                        header.setSectionResizeMode(1, QtWidgets.QHeaderView.ResizeToContents)
                        header.setSectionResizeMode(2, QtWidgets.QHeaderView.Stretch)

                        counter = 0
                        for key, val in process['parameters'].items():
                            # if key != "data" and key != "imagery":
                            qitem = QTableWidgetItem(key)
                            qitem.setFlags(QtCore.Qt.ItemIsEnabled)
                            if "required" in val:
                                if val["required"]:
                                    boldFont = QtGui.QFont()
                                    boldFont.setBold(True)
                                    qitem.setFont(boldFont)

                            self.processTableWidget.setItem(counter, 0, qitem)
                            if "schema" in val:
                                if "type" in val["schema"]:
                                    type = QTableWidgetItem(str(val['schema']['type']))
                                    type.setFlags(QtCore.Qt.ItemIsEnabled)
                                    self.processTableWidget.setItem(counter, 1, type)
                                if "examples" in val["schema"]:
                                    # type = QTableWidgetItem(str(val['schema']['type']))
                                    # type.setFlags(QtCore.Qt.ItemIsEnabled)
                                    # self.processTableWidget.setItem(counter, 2, type)
                                    example = QTableWidgetItem(str(val['schema']['examples'][0]))
                                    example.setFlags(QtCore.Qt.ItemIsEnabled)
                                    self.processTableWidget.setItem(counter, 2, example)
                                else:
                                    example = QTableWidgetItem("")
                                    example.setFlags(QtCore.Qt.ItemIsEnabled)
                                    self.processTableWidget.setItem(counter, 2, example)
                            counter += 1
                        return
                    else:
                        info(self.iface, "New Process: Parameters not found")

    def fill_item(self, item, value):
        """
        Helper method used by load_dict_into_widget
        """
        item.setExpanded(True)
        if type(value) is dict:
            for key, val in sorted(value.items()):
                child = QTreeWidgetItem()
                child.setText(0, str(key))
                item.addChild(child)
                self.fill_item(child, val)
        elif type(value) is list:
            for val in value:
                child = QTreeWidgetItem()
                item.addChild(child)
                if type(val) is dict:
                    child.setText(0, '[dict]')
                    self.fill_item(child, val)
                elif type(val) is list:
                    child.setText(0, '[list]')
                    self.fill_item(child, val)
                else:
                    child.setText(0, str(val))
                child.setExpanded(True)
        else:
            child = QTreeWidgetItem()
            child.setText(0, str(value))
            item.addChild(child)

    def load_dict_into_widget(self, widget, value):
        """
        Helper method to convert a dictionary into TreeWidgetItems, used e.g. for the process graph TreeWidget
        """
        widget.clear()
        self.fill_item(widget.invisibleRootItem(), value)
