# -*- coding: utf-8 -*-
"""
/***************************************************************************
 OpenEODialog
                                 A QGIS plugin
 Plugin to access openEO compliant backends.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2019-07-18
        git sha              : $Format:%H$
        copyright            : (C) 2019 by Bernhard Goesswein
        email                : bernhard.goesswein@geo.tuwien.ac.at
 ***************************************************************************/
/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
########################################################################################################################
########################################################################################################################

import os
import json
import requests
from os.path import expanduser
from collections import OrderedDict
import webbrowser

from qgis.PyQt import uic, QtGui, QtWidgets
from qgis.PyQt.QtWidgets import QTreeWidgetItem, QTableWidgetItem, QMainWindow, QFileDialog, QMessageBox
import qgis.PyQt.QtCore as QtCore
from qgis.core import QgsVectorLayer, QgsRasterLayer, QgsProject
from qgis.utils import iface

from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtWidgets import QPushButton, QHBoxLayout, QTextEdit, QListWidget, QListWidgetItem, QApplication, \
    QWidget, QLabel, QGridLayout, QVBoxLayout, QCalendarWidget, QDialog, QComboBox, QLineEdit

from PyQt5.QtCore import QDate, Qt, QSize, QSettings
from PyQt5.QtGui import QColor, QIcon, QPixmap

#from .models.models import Job
from .models.result import Result
from .models.connect import Connection
from .models.processgraph import Processgraph
from .models.openeohub import get_hub_backends, get_hub_jobs
from .utils.logging import info, warning
from distutils.version import LooseVersion

from .temp_dialog import TempDialog
from .spatial_dialog import SpatialDialog
from .band_dialog import BandDialog
from .job_detail_dialog import JobDetailDialog
from .job_adapt_dialog import JobAdaptDialog

os.environ["QT_AUTO_SCREEN_SCALE_FACTOR"] = "1"
QtWidgets.QApplication.setAttribute(QtCore.Qt.AA_EnableHighDpiScaling, True)  # enable highdpi scaling
QtWidgets.QApplication.setAttribute(QtCore.Qt.AA_UseHighDpiPixmaps, True)  # use highdpi icons

########################################################################################################################
########################################################################################################################

# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
FORM_CLASS, _ = uic.loadUiType(os.path.join(os.path.dirname(__file__), 'openeo_connector_dialog_base.ui'))


class OpenEODialog(QtWidgets.QDialog, FORM_CLASS):
    def __init__(self, parent=None, iface=None, backend=None):
        """Constructor method
        """
        super(OpenEODialog, self).__init__(parent)
        # Set up the user interface from Designer through FORM_CLASS.
        # After self.setupUi() you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://qt-project.org/doc/qt-4.8/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect

        QApplication.setStyle("cleanlooks")

        self.iface = iface
        self.processgraph = Processgraph()
        self.called = False
        self.called2 = False
        self.processes = None
        self.services_table = {}
        self.jobs_table = {}

        self.setupUi(self)

        self.operationManualBtn.clicked.connect(self.user_manual)

        self.collectionBox.currentTextChanged.connect(self.col_info)

        self.collectionBox.setEnabled(True)
        self.collectionBox.show()
        self.label_12.hide()

        self.processBox.currentTextChanged.connect(self.process_selected)

        #self.tabWidget.currentChanged.connect(self.empty_window)

        self.refreshButton.clicked.connect(self.refresh_jobs)
        #self.deleteButton.clicked.connect(self.del_job)
        #self.deleteFinalButton.clicked.connect(self.delete_job_final)
        self.refreshButton_service.clicked.connect(self.refresh_services)
        #self.deleteButton_service.clicked.connect(self.del_service)

        self.refreshButton.setEnabled(True)
        #self.deleteButton.setEnabled(True)
        #self.deleteFinalButton.setEnabled(True)
        self.refreshButton_service.setEnabled(True)
        #self.deleteButton_service.setEnabled(True)
        # self.deleteFinalButton_service.setEnabled(True)

        # Temporal Extent
        self.min_date = None
        self.max_date = None
        self.minimum_date = QDate()
        self.maximum_date = QDate()

        # Set initial button visibility correctly
        self.all_bands = []
        self.limit_west = -100000000000000000
        self.limit_east = 100000000000000000
        self.limit_north = 100000000000000000
        self.limit_south = -100000000000000000

        # Link to the Web Editor Demo Version:
        self.moveButton.clicked.connect(self.web_view)

        # Info Buttons about Datasets and Methods
        # self.collectionBox.setGeometry(10, 90, 401, 31)
        # self.infoBtn2.setStyleSheet('''
        #                                  border-image: url("./info_icon.png") 10 10 0 0;
        #                                  border-top: 10px transparent;
        #                                  border-bottom: 10px transparent;
        #                                  border-right: 0px transparent;
        #                                  border-left: 0px transparent''')
        self.infoBtn2.clicked.connect(self.pr_info)
        # self.processBox.setGeometry(10, 180, 401, 31)  # when add Button visible, set 381 to 291
        # self.infoBtn2.setGeometry(300, 180, 31, 31)  # remove, when add Button is visible
        self.infoBtn2.setEnabled(True)

        # Bands
        self.label_16.hide()
        self.label_16.setEnabled(False)

        # Adapt Job from Hub
        self.loadHubBtn.clicked.connect(self.load_job_from_hub)
        # self.insertChangeBtn.clicked.connect(self.adapt_temporal)
        # self.insertChangeBtn_2.clicked.connect(self.adapt_spatial)
        # self.insertChangeBtn_3.clicked.connect(self.adapt_bands)
        # self.insertChangeBtn_4.clicked.connect(self.adapt_collection)
        # self.insertChangeBtn.setEnabled(False)
        # self.insertChangeBtn_2.setEnabled(False)
        # self.insertChangeBtn_3.setEnabled(False)
        # self.insertChangeBtn_4.setEnabled(False)

        # self.set_font()
        # Jobs Tab
        self.init_jobs()
        self.init_services()

        self.tab_3.setEnabled(False)

        import copy
        self.backend = copy.deepcopy(backend)

        collection_result = self.backend.get_collections()

        # self.collectionBox.setGeometry(10, 90, 361, 31)
        self.infoBtn2.setVisible(True)

        # self.processBox.setGeometry(10, 180, 281, 31)  # when add Button is visible - set 351 to 261

        self.collectionBox.clear()
        self.processBox.clear()

        # Load Collections from Backend
        self.collectionBox.addItem("Choose one of the data sets listed below")
        for col in collection_result:
            if "id" in col:
                self.collectionBox.addItem(col['id'])

        # Load Processes from Backend
        self.processBox.addItem("Select a process")
        for key, val in self.backend.get_processes().items():
            self.processBox.addItem(key)

        self.refresh_jobs()
        self.refresh_services()

        if len(collection_result) == 0 and len(self.backend.get_processes()) == 0:
            warning(self.iface, "Backend URL does not have collections or processes defined, or is not valid!")
            return

        self.tab_3.setEnabled(True)

        self.backend_info()

        self.dlg = None

    # def set_font(self):
    #    QtWidgets.QApplication.setAttribute(QtCore.Qt.AA_EnableHighDpiScaling, True)  # enable highdpi scaling
    #    QtWidgets.QApplication.setAttribute(QtCore.Qt.AA_UseHighDpiPixmaps, True)  # use highdpi icons

    def limit_north(self):
        return self.limit_north

    def limit_west(self):
        return self.limit_west

    def limit_south(self):
        return self.limit_south

    def limit_east(self):
        return self.limit_east

    # def empty_window(self):
    #     window = str(self.processgraphEdit.toPlainText())
    #     if window == None:
    #         #self.sendButton.setEnabled(False)
    #         self.sendButton_service.setEnabled(False)
    #     elif window == "":
    #         #self.sendButton.setEnabled(False)
    #         self.sendButton_service.setEnabled(False)
    #     else:
    #         #self.sendButton.setEnabled(True)
    #         self.sendButton_service.setEnabled(True)

    def set_canvas(self):
        iface.actionPan().trigger()
        if iface.activeLayer():
            crs = iface.activeLayer().crs().authid()
            extent = iface.mapCanvas().extent()
            self.east = round(extent.xMaximum(), 2)
            self.north = round(extent.yMaximum(), 2)
            self.west = round(extent.xMinimum(), 2)
            self.south = round(extent.yMinimum(), 2)
            spatial_extent = {}
            spatial_extent["west"] = self.west
            spatial_extent["east"] = self.east
            spatial_extent["north"] = self.north
            spatial_extent["south"] = self.south
            spatial_extent["crs"] = crs
            str_format = str(spatial_extent).replace("'", '"')
            # self.processgraphSpatialExtent.setText(str_format)
            self.check_spatial_cover()
        elif not iface.activeLayer():
            self.iface.messageBar().pushMessage("Please open a new layer to get extent from.", duration=5)

    def check_spatial_cover(self):
        west = self.west
        east = self.east
        north = self.north
        south = self.south
        if west < self.limit_west:
            self.iface.messageBar().pushMessage("Your Choice of extent is not covered by the data provider.",
                                                duration=5)
        if east > self.limit_east:
            self.iface.messageBar().pushMessage("Your Choice of extent is not covered by the data provider.",
                                                duration=5)
        if south < self.limit_south:
            self.iface.messageBar().pushMessage("Your Choice of extent is not covered by the data provider.",
                                                duration=5)
        if north > self.limit_north:
            self.iface.messageBar().pushMessage("Your Choice of extent is not covered by the data provider.",
                                                duration=5)

    def spatial_limits(self):
        collection_result = self.backend.get_collections()
        selected_process = str(self.collectionBox.currentText())
        for col in collection_result:
            if str(col['id']) == selected_process:
                if "extent" in col:
                    # in case nothing is listed:
                    self.limit_west = col['extent']['spatial'][0]
                    self.limit_south = col['extent']['spatial'][1]
                    self.limit_east = col['extent']['spatial'][2]
                    self.limit_north = col['extent']['spatial'][3]
                    # self.processgraphSpatialExtent.setText(str(self.limit_west) + " " + str(self.limit_east) + " " + str(self.limit_south) + " " + str(self.limit_north))

    def date_limits(self):
        # Get min and max date from each collection
        collection_result = self.backend.get_collections()
        selected_process = str(self.collectionBox.currentText())
        for col in collection_result:
            if str(col['id']) == selected_process:
                if "extent" in col:
                    # in case nothing is listed:
                    if col['extent']['temporal'] == "[]":
                        self.end_calendar.setMaximumDate(QDate.currentDate())
                        self.EndDateEdit.setMaximumDate(QDate.currentDate())
                    else:
                        # set minimum date
                        self.min_date = col['extent']['temporal'][0]
                        self.min_year = self.min_date[0:4]
                        self.min_month = self.min_date[5:7]
                        self.min_day = self.min_date[8:10]
                        self.minimum_date = QDate(int(self.min_year), int(self.min_month), int(self.min_day))
                        self.StartDateEdit.setDate(self.minimum_date)

                        # set maximum date
                        self.max_date = col['extent']['temporal'][1]
                        if self.max_date == None:
                            self.max_date = None
                            self.EndDateEdit.setDate(QDate.currentDate())
                        else:
                            self.max_year = self.max_date[0:4]
                            self.max_month = self.max_date[5:7]
                            self.max_day = self.max_date[8:10]
                            self.maximum_date = QDate(int(self.max_year), int(self.max_month), int(self.max_day))
                            self.EndDateEdit.setDate(self.maximum_date)

    def web_view(self):
        webbrowser.open("https://open-eo.github.io/openeo-web-editor/demo/")
        # QWebEngineView, QWebView...

    def web_view_close(self):
        self.webWindow.close()
        return

    def load_job_from_hub(self):
        self.example_hub_jobs = get_hub_jobs()

        # Open a window, where desired job can be selected
        self.hub_jobs_window = QDialog(parent=self)
        hbox6 = QHBoxLayout()
        self.exampleJobBox = QListWidget()
        for job in self.example_hub_jobs:
            job_item = QListWidgetItem(self.exampleJobBox)
            job_item.setFlags(
                job_item.flags() | QtCore.Qt.ItemIsSelectable)  # only one item can be selected this time
            job_item.setSelected(False)
            job_item.setText(job.title)  # add Titles as QListWidgetItems

        self.exampleJobBox.setMinimumWidth(500)

        closeWindowBtn = QPushButton('Show process graph \n and close window')
        hbox6.addWidget(self.exampleJobBox)
        hbox6.addWidget(closeWindowBtn)
        closeWindowBtn.clicked.connect(self.pick_job_from_hub)
        self.hub_jobs_window.setLayout(hbox6)
        self.hub_jobs_window.setWindowTitle('Select a Job')
        self.hub_jobs_window.show()

    def pick_job_from_hub(self):
        selected_row = self.exampleJobBox.currentRow()
        self.hub_jobs_window.close()

        job = self.example_hub_jobs[selected_row].to_job()

        self.dlg = JobAdaptDialog(iface=self.iface, job=job, backend=self.backend)
        self.dlg.setWindowFlags(Qt.WindowStaysOnTopHint)
        self.dlg.show()
        # self.insertChangeBtn.setEnabled(True)
        # self.insertChangeBtn_2.setEnabled(True)
        # self.insertChangeBtn_3.setEnabled(True)
        # self.insertChangeBtn_4.setEnabled(True)
        #
        #
        # selected_row = self.exampleJobBox.currentRow()
        # self.hub_jobs_window.close()
        # self.example_job = json.loads(self.example_hub_jobs[selected_row].process_graph)
        # self.processgraphEdit.setText(json.dumps(self.example_job, indent=4))

    def user_manual(self):
        self.umWindow = QDialog(parent=self)
        self.grid = QGridLayout()

        # User Manual Text
        self.text = QLabel()
        user_manual_text = open(os.path.join(os.path.dirname(__file__), './user_manual_text.txt')).read()
        self.text.setText(str(user_manual_text))
        # Title
        self.title = QLabel()
        self.title.setText("User Manual \n ")
        self.startText = QLabel()
        self.startText.setText("1. At first, please focus on the upper part (header) of the openEO Plugin. "
                               "There, you can choose a back-end and enter your login credentials. \nBy clicking"
                               "the “Connect”-Button, you will be connected with the chosen back-end. \nIf the connection "
                               "was successful you will see it in the Status text. \n")
        # openEO Header Image
        self.image = QLabel()
        self.image.setPixmap(QPixmap(os.path.join(os.path.dirname(__file__), 'openEO_plugin_header.png')))

        self.grid.setSpacing(4)
        self.grid.addWidget(self.title, 0, 0)
        self.grid.addWidget(self.startText, 1, 0)
        self.grid.addWidget(self.image, 2, 0)
        self.grid.addWidget(self.text, 4, 0)
        self.umWindow.setLayout(self.grid)
        self.umWindow.setWindowTitle('User Manual')
        self.umWindow.show()

        # self.jobsTableWidget.setColumnCount(8)
        # self.jobsTableWidget.setHorizontalHeaderLabels(['Job Id', 'Description/Error', 'Submission Date', 'Status',
        #                                                 'Execute', 'Display', 'Adapt', 'Information'])
        # header = self.jobsTableWidget.horizontalHeader()
        # header.setSectionResizeMode(0, QtWidgets.QHeaderView.Stretch)
        # header.setSectionResizeMode(1, QtWidgets.QHeaderView.ResizeToContents)
        # header.setSectionResizeMode(2, QtWidgets.QHeaderView.ResizeToContents)

    def col_info(self):
        collection_info_result = self.backend.get_collections()
        selected_col = str(self.collectionBox.currentText())
        for col_info in collection_info_result:
            if str(col_info['id']) == selected_col:
                if "description" in col_info:
                    self.collectionInfo.setText(str(col_info['id']) + ': ' + str(col_info['description']))

    def backend_info(self):
        backend_info = self.backend.get_metadata()

        if "description" in backend_info:
            self.backendInfo.setText(str(backend_info["description"]))

    def pr_info(self):

        process = self.backend.get_process(str(self.processBox.currentText()))

        if not process:
            return

        self.infoWindow2 = QDialog(parent=self)
        self.hbox2 = QHBoxLayout()
        self.infoBox = QTextEdit()

        if process.returns:
            self.infoBox.setText(
                str(str(process.id) + ': ' + str(process.description) + "\n\n Returns: \n" + str(process.get_return_type()) + "\n" +
                    process.returns["description"]))
        else:
            self.infoBox.setText(
                str(str(process.id) + ': ' + str(process.description)))

        self.infoBox.setReadOnly(True)
        self.infoBox.setMinimumWidth(500)
        self.infoBox.setMinimumHeight(500)
        self.hbox2.addWidget(self.infoBox)
        self.infoWindow2.setLayout(self.hbox2)
        # self.infoWindow2.setGeometry(400, 400, 600, 350)
        self.infoWindow2.setWindowTitle('Process Information')
        self.infoWindow2.show()
        # self.processgraphEdit.setText(str(pr_info['id']) + ": " + str(pr_info['description']))

    def job_info(self, row):
        """
        Returns detailed information about a submitted batch job in a PopUp-Window, such as:
        - Start time
        - Description
        - Progress
        - Cost
        - ...
        :param row: Integer number of the row the button is clicked.
        """

        # job_id = self.jobsTableWidget.item(row, 1).text()
        job = self.jobs_table[row]
        #info = self.backend.job_info(job.id)
        #warning(self.iface, "Job {} detailed information: {}".format(job.id, info))
        job = self.backend.detailed_job(job.id)

        self.dlg = JobDetailDialog(iface=self.iface, job=job, backend=self.backend)
        self.dlg.setWindowFlags(Qt.WindowStaysOnTopHint)
        self.dlg.show()

        # job_info = self.backend.job_info(job_id)
        # self.infoWindow3 = QDialog(parent=self)
        # self.hbox3 = QHBoxLayout()
        # self.infoBox3 = QTextEdit()
        # self.infoBox3.setText(str(job_info))
        # self.infoBox3.setReadOnly(True)
        # self.hbox3.addWidget(self.infoBox3)
        # self.infoWindow3.setLayout(self.hbox3)
        # #self.infoWindow3.setGeometry(400, 400, 600, 450)
        # self.infoWindow3.setWindowTitle('Job Information')
        # self.infoWindow3.show()

    def service_info(self, row):
        service = self.services_table[row]
        service_info = self.backend.service_info(service.id)
        self.infoWindow5 = QDialog(parent=self)
        self.hbox7 = QHBoxLayout()
        self.infoBox2 = QTextEdit()
        self.infoBox2.setText(str(service_info))
        self.infoBox2.setReadOnly(True)
        self.hbox7.addWidget(self.infoBox2)
        self.infoWindow5.setLayout(self.hbox7)
        #self.infoWindow5.setGeometry(400, 400, 600, 450)
        self.infoWindow5.setWindowTitle('Service Information')
        self.infoWindow5.show()

    def pg_info_job(self, row):
        """
        Returns detailed information about a the process graph of a batch job in a PopUp-Window:
        :param row: Integer number of the row the button is clicked.
        """
        job_id = self.jobs_table[row].id
        # job_id = self.jobsTableWidget.item(row, 1).text()
        process_graph_job = self.backend.job_pg_info(job_id)

        self.infoWindow4 = QDialog(parent=self)
        self.hbox5 = QVBoxLayout()
        self.infoBox4 = QTextEdit()
        self.infoBox4.setText(json.dumps(process_graph_job, indent=4))
        self.infoBox4.setReadOnly(True)
        self.infoBox4.setMinimumWidth(500)
        self.infoBox4.setMinimumHeight(800)
        self.copy_and_adaptBtn = QPushButton('Copy and Adapt Job Process Graph in QGIS Plugin')
        self.copy_and_adaptBtn.move(20, 10)
        self.hbox5.addWidget(self.infoBox4)
        self.hbox5.addWidget(self.copy_and_adaptBtn)
        self.infoWindow4.setLayout(self.hbox5)
        #self.infoWindow4.setGeometry(400, 400, 600, 450)
        self.infoWindow4.setWindowTitle('Job Process Graph')
        self.infoWindow4.show()
        self.copy_and_adaptBtn.clicked.connect(self.copy_and_adapt_job)

    def pg_info_service(self, row):
        """
        Returns detailed information about a the process graph of a batch job in a PopUp-Window:
        :param row: Integer number of the row the button is clicked.
        """
        service_id = self.servicesTableWidget.item(row, 1).text()
        process_graph_service = self.backend.service_pg_info(service_id)

        self.infoWindow6 = QDialog(parent=self)
        self.hbox8 = QVBoxLayout()
        self.infoBox5 = QTextEdit()
        self.infoBox5.setText(json.dumps(process_graph_service, indent=4))
        self.infoBox5.setReadOnly(True)
        self.infoBox5.setMinimumWidth(500)
        self.infoBox5.setMinimumHeight(800)
        self.copy_adaptBtn = QPushButton('Copy and Adapt Service Process Graph in QGIS Plugin')
        self.copy_adaptBtn.move(120, 280)
        self.hbox8.addWidget(self.infoBox5)
        self.hbox8.addWidget(self.copy_adaptBtn, Qt.RightButton)
        self.infoWindow6.setLayout(self.hbox8)
        #self.infoWindow6.setGeometry(400, 400, 600, 450)
        self.infoWindow6.setWindowTitle('Service Process Graph')
        self.infoWindow6.show()
        self.copy_adaptBtn.clicked.connect(self.copy_and_adapt_service)

    # def copy_and_adapt_job(self):
    #     self.processgraphEdit.setText(self.infoBox4.toPlainText()) #str().replace("'", '"').replace("None", '"None"').replace("True", '"True"'))
    #     self.infoWindow4.close()
    #     self.tabWidget.setCurrentIndex(1)
    #
    #     # Enable Buttons
    #     # self.insertChangeBtn.setEnabled(True)
    #     self.insertChangeBtn_2.setEnabled(True)
    #     self.insertChangeBtn_3.setEnabled(True)
    #     self.insertChangeBtn_4.setEnabled(True)
    #
    # def copy_and_adapt_service(self):
    #     self.processgraphEdit.setText(json.dumps(str(self.infoBox4.toPlainText()), indent=4)) #(str(self.infoBox5.toPlainText()).replace("'", '"').replace("None", '"None"').replace("True", '"True"'))
    #     self.infoWindow6.close()
    #     self.tabWidget.setCurrentIndex(1)
    #
    #     # Enable Buttons
    #     self.insertChangeBtn.setEnabled(True)
    #     self.insertChangeBtn_2.setEnabled(True)
    #     self.insertChangeBtn_3.setEnabled(True)
    #     self.insertChangeBtn_4.setEnabled(True)

    def init_jobs(self):
        """
        Initializes the jobs table
        """
        self.jobsTableWidget.clear()

        self.jobsTableWidget.setColumnCount(8)
        self.jobsTableWidget.setHorizontalHeaderLabels(['Job Title', 'Created', 'Status', 'Execute', 'Display', 'Adapt',
                                                        'Information', 'Delete'])
        header = self.jobsTableWidget.horizontalHeader()
        self.jobsTableWidget.setSortingEnabled(True)
        header.setSectionResizeMode(0, QtWidgets.QHeaderView.Stretch)
        header.setSectionResizeMode(1, QtWidgets.QHeaderView.ResizeToContents)
        header.setSectionResizeMode(2, QtWidgets.QHeaderView.Interactive)
        header.setSectionResizeMode(3, QtWidgets.QHeaderView.Interactive)
        header.setSectionResizeMode(4, QtWidgets.QHeaderView.Interactive)
        header.setSectionResizeMode(5, QtWidgets.QHeaderView.Interactive)
        header.setSectionResizeMode(6, QtWidgets.QHeaderView.Interactive)
        header.setSectionResizeMode(7, QtWidgets.QHeaderView.Interactive)

    def init_services(self):
        """
        Initializes the services table
        """
        self.servicesTableWidget.clear()

        self.servicesTableWidget.setColumnCount(6)
        self.servicesTableWidget.setHorizontalHeaderLabels(['Title', 'Description',
                                                            'Created', 'Display', 'Information', 'Delete'])

        header = self.servicesTableWidget.horizontalHeader()
        self.servicesTableWidget.setSortingEnabled(True)
        header.setSectionResizeMode(0, QtWidgets.QHeaderView.Interactive)
        header.setSectionResizeMode(1, QtWidgets.QHeaderView.ResizeToContents)
        header.setSectionResizeMode(2, QtWidgets.QHeaderView.ResizeToContents)
        header.setSectionResizeMode(3, QtWidgets.QHeaderView.Interactive)
        header.setSectionResizeMode(4, QtWidgets.QHeaderView.Interactive)
        header.setSectionResizeMode(5, QtWidgets.QHeaderView.Interactive)

    def refresh_jobs(self):
        """
        Refreshes the job table, so fetches all jobs of the user from the backend and lists them in the table.
        This method also generates the "Execute" and "Display" buttons.
        """

        jobs = self.backend.get_jobs()

        if not isinstance(jobs, list):
            jobs = []

        self.init_jobs()
        self.jobsTableWidget.setRowCount(len(jobs))
        row = 0
        self.jobs_table = {}
        for job in jobs:

            if job.created:
                qitem = QTableWidgetItem(job.created.strftime("%Y-%m-%d_%H-%M-%S"))
                qitem.setFlags(QtCore.Qt.ItemIsEnabled)
                self.jobsTableWidget.setItem(row, 1, qitem)

            if not job.title:
                qitem = QTableWidgetItem("Untitled Job!")
                qitem.setFlags(QtCore.Qt.ItemIsEnabled)
                self.jobsTableWidget.setItem(row, 0, qitem)
            else:
                qitem = QTableWidgetItem(job.title)
                qitem.setFlags(QtCore.Qt.ItemIsEnabled)
                self.jobsTableWidget.setItem(row, 0, qitem)

            # if val.error:
            #     if val["error"]:
            #         if "message" in val["error"]:
            #             qitem = QPushButton(self.jobsTableWidget)
            #             qitem.setText("Show")
            #             #qitem.setFlags(QtCore.Qt.ItemIsEnabled)
            #             msg = val["error"]["message"]
            #             qitem.clicked.connect(lambda: self.show_error_message(msg))
            #             self.jobsTableWidget.setCellWidget(row, 7, qitem)

            execBtn = QPushButton(self.jobsTableWidget)
            execBtn.setIcon(QIcon(os.path.join(os.path.dirname(__file__), 'execute_icon.png')))
            execBtn.setIconSize(QSize(21, 21))

            if job.status:
                qitem = QTableWidgetItem(job.status)
                qitem.setFlags(QtCore.Qt.ItemIsEnabled)
                self.jobsTableWidget.setItem(row, 2, qitem)

                if job.status == "finished":
                    self.jobsTableWidget.item(row, 2).setBackground(QColor(75, 254, 40, 160))
                    dispBtn = QPushButton(self.jobsTableWidget)
                    dispBtn.setIcon(QIcon(os.path.join(os.path.dirname(__file__), 'display_icon.png')))
                    dispBtn.setIconSize(QSize(29, 29))
                    self.jobsTableWidget.setCellWidget(row, 4, dispBtn)
                    dispBtn.clicked.connect(lambda *args, row=row: self.job_display(row))
                    iface.actionZoomIn().trigger()

                elif job.status == "running":
                    self.jobsTableWidget.item(row, 2).setBackground(QColor(254, 178, 76, 200))

                elif job.status == "error":
                    self.jobsTableWidget.item(row, 2).setBackground(QColor(254, 100, 100, 200))

            self.jobsTableWidget.setCellWidget(row, 3, execBtn)
            execBtn.clicked.connect(lambda *args, row=row: self.job_execute(row))

            infoBtn2 = QPushButton(self.jobsTableWidget)
            infoBtn2.setIcon(QIcon(os.path.join(os.path.dirname(__file__), 'edit_icon.png')))
            infoBtn2.setIconSize(QSize(25, 25))
            self.jobsTableWidget.setCellWidget(row, 5, infoBtn2)
            infoBtn2.clicked.connect(lambda *args, row=row: self.adapt_job(row))

            infoBtn3 = QPushButton(self.jobsTableWidget)
            infoBtn3.setIcon(QIcon(os.path.join(os.path.dirname(__file__), 'info_icon.png')))
            infoBtn3.setIconSize(QSize(25, 25))
            self.jobsTableWidget.setCellWidget(row, 6, infoBtn3)
            infoBtn3.clicked.connect(lambda *args, row=row: self.job_info(row))

            infoBtn4 = QPushButton(self.jobsTableWidget)
            infoBtn4.setIcon(QIcon(os.path.join(os.path.dirname(__file__), 'deleteFinalBtn.png')))
            infoBtn4.setIconSize(QSize(25, 25))
            self.jobsTableWidget.setCellWidget(row, 7, infoBtn4)
            infoBtn4.clicked.connect(lambda *args, row=row: self.delete_job_final(row))

            # self.processGraphBtn = QPushButton(self.jobsTableWidget)
            # self.processGraphBtn.setIcon(QIcon(os.path.join(os.path.dirname(__file__), 'processGraph_icon.png')))
            # self.processGraphBtn.setIconSize(QSize(22, 22))
            # self.jobsTableWidget.setCellWidget(row, 6, self.processGraphBtn)
            # self.processGraphBtn.clicked.connect(lambda *args, row=row: self.pg_info_job(row))

            self.refreshButton.setEnabled(True)
            #self.deleteButton.setEnabled(True)
            # self.deleteFinalButton.setEnabled(True)
            self.refreshButton_service.setEnabled(True)
            #self.deleteButton_service.setEnabled(True)
            # self.deleteFinalButton_service.setEnabled(True)
            # self.deleteFinalButton.clicked.connect(lambda *args, row=row: self.delete_job_final(row))
            # self.deleteFinalButton_service.clicked.connect(lambda *args, row=row: self.delete_service_final(row))

            self.jobs_table[row] = job

            row += 1

    def show_error_message(self, msg):
        """
                Shows a detailed information about
                a the error of a batch job in a PopUp-Window:
                :param msg: Error message that should be shown in the window.
                """
        #service_id = self.servicesTableWidget.item(row, 1).text()
        #process_graph_service = self.connection.pg_info_service(service_id)

        self.infoWindow6 = QDialog(parent=self)
        self.hbox8 = QVBoxLayout()
        self.infoBox5 = QTextEdit()
        self.infoBox5.setText(msg)
        self.infoBox5.setReadOnly(True)
        self.infoBox5.setMinimumWidth(500)
        self.infoBox5.setMinimumHeight(800)
        self.hbox8.addWidget(self.infoBox5)
        self.infoWindow6.setLayout(self.hbox8)
        # self.infoWindow6.setGeometry(400, 400, 600, 450)
        self.infoWindow6.setWindowTitle('Error Message')
        self.infoWindow6.show()

    def refresh_services(self):
        """
        Refreshes the job table, so fetches all jobs of the user from the backend and lists them in the table.
        This method also generates the "Execute" and "Display" buttons.
        """

        services = self.backend.get_services()

        if not isinstance(services, list):
            services = []

        self.init_services()
        self.servicesTableWidget.setRowCount(len(services))
        row = 0
        self.services_table = {}

        for serv in services:
            # self.processgraphEdit.setText(val)
            if serv.title:
                if serv.title == None:
                    qitem = QTableWidgetItem("Untitled Service!")
                    qitem.setFlags(QtCore.Qt.ItemIsEnabled)
                    self.servicesTableWidget.setItem(row, 0, qitem)
                else:
                    qitem = QTableWidgetItem(serv.title)
                    qitem.setFlags(QtCore.Qt.ItemIsEnabled)
                    self.servicesTableWidget.setItem(row, 0, qitem)

            if serv.description:
                qitem = QTableWidgetItem(serv.description)
                qitem.setFlags(QtCore.Qt.ItemIsEnabled)
                self.servicesTableWidget.setItem(row, 1, qitem)

            if serv.created:
                qitem = QTableWidgetItem(serv.created.strftime("%Y-%m-%d_%H-%M-%S"))
                qitem.setFlags(QtCore.Qt.ItemIsEnabled)
                self.servicesTableWidget.setItem(row, 2, qitem)

            displayBtn = QPushButton(self.servicesTableWidget)
            displayBtn.setIcon(QIcon(os.path.join(os.path.dirname(__file__), 'display_icon.png')))
            displayBtn.setIconSize(QSize(29, 29))

            self.servicesTableWidget.setCellWidget(row, 3, displayBtn)
            displayBtn.clicked.connect(lambda *args, row=row: self.service_execute(serv.url, serv.id))

            infoBtn2 = QPushButton(self.servicesTableWidget)
            infoBtn2.setIcon(QIcon(os.path.join(os.path.dirname(__file__), 'info_icon.png')))
            infoBtn2.setIconSize(QSize(25, 25))
            self.servicesTableWidget.setCellWidget(row, 4, infoBtn2)
            infoBtn2.clicked.connect(lambda *args, row=row: self.service_info(row))

            infoBtn3 = QPushButton(self.servicesTableWidget)
            infoBtn3.setIcon(QIcon(os.path.join(os.path.dirname(__file__), 'deleteFinalBtn.png')))
            infoBtn3.setIconSize(QSize(25, 25))
            self.servicesTableWidget.setCellWidget(row, 5, infoBtn3)
            infoBtn3.clicked.connect(lambda *args, row=row: self.delete_service_final(row))

            # self.processGraphBtn_service = QPushButton(self.jobsTableWidget)
            # self.processGraphBtn_service.setIcon(QIcon(os.path.join(os.path.dirname(__file__), 'processGraph_icon.png')))
            # self.processGraphBtn_service.setIconSize(QSize(22, 22))
            # self.servicesTableWidget.setCellWidget(row, 4, self.processGraphBtn_service)
            # self.processGraphBtn_service.clicked.connect(lambda *args, row=row: self.pg_info_service(row))

            self.services_table[row] = serv

            row += 1

    def service_execute(self, url, id):
        """
        Executes the job of the given row of the job table.
        This method is called after the "Execute" button is clicked at the job table.
        :param row: Integer number of the row the button is clicked.
        """
        urlWithParams = 'type=xyz&url={}'.format(url)
        # urlWithParams = 'type=xyz&url={}&zmax=19&zmin=0&crs=EPSG3857'.format(url)

        rlayer = QgsRasterLayer(urlWithParams, 'OpenEO-{}'.format(id), 'wms')

        # rlayer = QgsRasterLayer("type=xyz&url=http://c.tile.openstreetmap.org/{z}/{x}/{y}.png", "OSM", "wms")

        if rlayer.isValid():
            QgsProject.instance().addMapLayer(rlayer)
        else:
            print('invalid layer')

    def job_execute(self, row):
        """
        Executes the job of the given row of the job table.
        This method is called after the "Execute" button is clicked at the job table.
        :param row: Integer number of the row the button is clicked.
        """
        job_id = self.jobs_table[row].id

        self.backend.job_start(job_id)
        self.refresh_jobs()

    def adapt_job(self, row):

        job = self.jobs_table[row]
        job = self.backend.detailed_job(job.id)

        self.dlg = JobAdaptDialog(iface=self.iface, job=job, backend=self.backend)
        self.dlg.setWindowFlags(Qt.WindowStaysOnTopHint)
        self.dlg.show()

    def job_display(self, row):
        """
        Displays the job of the given row of the job table on a new QGis Layer.
        This method is called after the "Display" button is clicked at the job table.
        :param row: Integer number of the row the button is clicked.
        """
        job = self.jobs_table[row]

        process_graph_job = self.backend.job_pg_info(job.id)
        download_dir = self.backend.job_result_download(job.id)
        if download_dir:
            for ddir in download_dir:
                info(self.iface, "Downloaded to {}".format(ddir))
                result = Result(path=ddir, process_graph=process_graph_job)
                if iface.activeLayer():
                    crs_background = iface.activeLayer().crs().authid()
                    QSettings().setValue('/Projections/defaultBehaviour', 'useGlobal')
                    QSettings().setValue('/Projections/layerDefaultCrs', crs_background)
                else:
                    QSettings().setValue('/Projections/defaultBehaviour', 'useGlobal')
                    QSettings().setValue('/Projections/layerDefaultCrs', 'EPSG:4326')

                if job.title:
                    title = job.title
                else:
                    title = "NoTitle"

                result.display(layer_name="{}-{}".format(title, job.created.strftime("%Y-%m-%d_%H-%M-%S")))
                iface.zoomToActiveLayer()

        self.refresh_jobs()

    def send_job(self):
        """
        Sends the current process graph to the backend to create a new job.
        """
        title_window = QDialog(parent=self)

        title = QLineEdit()
        ok_button = QPushButton()
        cancel_button = QPushButton()

        title.setMinimumWidth(200)

        ok_button.setText("Ok")
        cancel_button.setText("Cancel")

        ok_button.clicked.connect(lambda: self.send_job_backend(title.text(), title_window))
        cancel_button.clicked.connect(title_window.reject)

        vbox = QVBoxLayout()
        vbox.addWidget(title)

        hbox = QHBoxLayout()
        hbox.addWidget(ok_button)
        hbox.addWidget(cancel_button)

        vbox.addLayout(hbox)
        title_window.setLayout(vbox)
        title_window.setWindowTitle('Choose Title')
        title_window.show()

    # def send_job_backend(self, title=None, dialog=None):
    #     graph = self.processgraphEdit.toPlainText()
    #     # info(self.iface, graph)
    #     response = self.backend.job_create(json.loads(graph), title=title)
    #     if response.status_code == 201:
    #         info(self.iface, "Successfully created new job, Response: {}".format(response.status_code))
    #     else:
    #         warning(self.iface, "Not able to created new job, Response: {}".format(str(response.json())))
    #
    #     self.refresh_jobs()
    #     if dialog:
    #         dialog.close()

    # def send_service(self):
    #     """
    #     Sends the current process graph to the backend to create a new service.
    #     """
    #     graph = self.processgraphEdit.toPlainText()
    #     # info(self.iface, graph)
    #     response = self.backend.service_create(json.loads(graph))
    #     if response.status_code == 201:
    #         info(self.iface, "Successfully created new service, Response: {}".format(response.status_code))
    #     else:
    #         warning(self.iface, "Not able to created new service, Response: {}".format(str(response.json())))
    #
    #     self.refresh_services()

    # def del_job(self):
    #     self.chosenRow = self.jobsTableWidget.currentRow()
    #     self.jobsTableWidget.removeRow(self.chosenRow)

    def delete_job_final(self, row):
        job_name = self.jobs_table[row].title
        sure = self.yes_no_dialog("Are you sure you want to delete Job '{}'?".format(job_name))

        if not sure:
            return

        job_id = self.jobs_table[row].id
        self.backend.job_delete(job_id)
        self.refresh_jobs()

    # def del_service(self):
    #     self.chosenRow = self.servicesTableWidget.currentRow()
    #     self.servicesTableWidget.removeRow(self.chosenRow)

    def yes_no_dialog(self, message):

        reply = QMessageBox.question(self, "Are you sure?",
                                     message, QMessageBox.Yes, QMessageBox.Cancel)

        if reply == QMessageBox.Yes:
            #self.setWindowFlags(Qt.WindowStaysOnTopHint)
            return True
        else:
            #self.setWindowFlags(Qt.WindowStaysOnTopHint)
            return False

    def delete_service_final(self, row):

        service = self.services_table[row]

        sure = self.yes_no_dialog("Are you sure you want to delete Service '{}'?".format(service.title))

        if not sure:
            return

        self.backend.service_delete(service.id)
        self.refresh_services()

    def clear(self):
        # self.processgraphEdit.clear()
        self.sendButton.setEnabled(False)
        self.sendButton_service.setEnabled(False)

    # def reload_processgraph_view(self):
    #     """
    #     Reloads the process graph tree widget by loading the current processgraph into it.
    #     """
    #     # widget = self.processgraphWidget
    #     # self.load_dict_into_widget(widget, self.processgraph.graph)
    #     self.processgraphEdit.setText(json.dumps(self.processgraph.graph, indent=2, sort_keys=True))
    #     # widget.show()

    def process_selected(self):
        """
        Gets called if a new process is selected at the process combobox.
        It loads all agruments with their type and an example (if exist) into the value
        """
        self.processTableWidget.clear()
        pr = self.backend.get_process(str(self.processBox.currentText()))

        if not pr:
            return

        self.returnLabel.setText(str(pr.get_return_type()))

        # info(self.iface, "New Process {}".format(process['parameters']))
        self.processTableWidget.setRowCount(len(pr.parameters))
        self.processTableWidget.setColumnCount(3)
        self.processTableWidget.setHorizontalHeaderLabels(['Parameter', 'Type', 'Description'])
        header = self.processTableWidget.horizontalHeader()
        header.setSectionResizeMode(0, QtWidgets.QHeaderView.ResizeToContents)
        header.setSectionResizeMode(1, QtWidgets.QHeaderView.ResizeToContents)
        header.setSectionResizeMode(2, QtWidgets.QHeaderView.Stretch)

        counter = 0
        for param in pr.parameters:
            # if key != "data" and key != "imagery":
            qitem = QTableWidgetItem(param.name)
            qitem.setFlags(QtCore.Qt.ItemIsEnabled)

            if not param.optional:
                boldFont = QtGui.QFont()
                boldFont.setBold(True)
                qitem.setFont(boldFont)

            self.processTableWidget.setItem(counter, 0, qitem)

            type = QTableWidgetItem(str(param.get_type()))
            type.setFlags(QtCore.Qt.ItemIsEnabled)
            self.processTableWidget.setItem(counter, 1, type)

            if param.description:
                desc = QTableWidgetItem(str(param.description))
                desc.setFlags(QtCore.Qt.ItemIsEnabled)
                self.processTableWidget.setItem(counter, 2, desc)
            else:
                desc = QTableWidgetItem("")
                desc.setFlags(QtCore.Qt.ItemIsEnabled)
                self.processTableWidget.setItem(counter, 2, desc)

            counter += 1

    def fill_item(self, item, value):
        """
        Helper method used by load_dict_into_widget
        """
        item.setExpanded(True)
        if type(value) is dict:
            for key, val in sorted(value.items()):
                child = QTreeWidgetItem()
                child.setText(0, str(key))
                item.addChild(child)
                self.fill_item(child, val)
        elif type(value) is list:
            for val in value:
                child = QTreeWidgetItem()
                item.addChild(child)
                if type(val) is dict:
                    child.setText(0, '[dict]')
                    self.fill_item(child, val)
                elif type(val) is list:
                    child.setText(0, '[list]')
                    self.fill_item(child, val)
                else:
                    child.setText(0, str(val))
                child.setExpanded(True)
        else:
            child = QTreeWidgetItem()
            child.setText(0, str(value))
            item.addChild(child)

    def load_dict_into_widget(self, widget, value):
        """
        Helper method to convert a dictionary into TreeWidgetItems, used e.g. for the process graph TreeWidget
        """
        widget.clear()
        self.fill_item(widget.invisibleRootItem(), value)
